from typing import Dict

import torch

from . import _NegativeSampler


class UniformSampler(_NegativeSampler):
    r"""UniformSampler is to generate negative samplers by uniform distribution, i.e. draw samples uniformly
    """

    def __init__(self,
                 with_replacement: bool,
                 **kwargs_dict):
        r"""Initialize 
        
        Args:
            with_replacement (bool): To choose whether samples are generated with or without replacement.
        
        Raises:
            TypeError: when with_replacement is not a boolean variable.
        """
        # Refer to parent class
        super(UniformSampler, self).__init__(**kwargs_dict)

        # Bind with_replacement to with_replacement
        if not isinstance(with_replacement, bool):
            raise TypeError(f"{type(with_replacement)}.__name__ is not allowed.")

        # Bind method to _generate
        self.with_replacement = with_replacement
        if self.with_replacement is True:
            self._generate = self._generate_with_replacement
        else:
            self._generate = self._generate_without_replacement

    def size(self) -> Dict[str, int]:
        r"""Get length of field.
        
        Returns:
            int: Length of field.
        """
        return {k: v["high"] - v["low"] for k, v in self.kwargs.items()}

    @staticmethod
    def _generate_with_replacement(**kwargs: Dict[str, int]) -> torch.Tensor:
        r"""A function to generate negative samples with uniform distribution with replacement.
        
        Arguments:
            low (int): Lowest integer to be drawn from the distribution.
            high (int): One above the highest integer to be drawn from the distribution.
            size (int): An integer defining the shape of the output tensor.
        
        Returns:
            T, shape = (N * Nneg, 1), dtype = torch.long: Tensor of negative samples generated by uniform distribution.
        """
        return torch.randint(low=kwargs["low"], high=kwargs["high"], size=(kwargs["size"], 1)).long()

    @staticmethod
    def _generate_without_replacement(**kwargs: Dict[str, int]) -> torch.Tensor:
        r"""A function to generate negative samples with uniform distribution without replacement.
        
        Arguments:
            low (int): minimum value (i.e. lower bound) of sampling id.
            high (int): maximum value (i.e. upper bound) of sampling id.
            size (int): An integer of defining the shape of the output tensor.
        
        Returns:
            T, shape = (N * Nneg, 1), dtype = torch.long: Tensor of negative samples generated by uniform distribution.
        """
        samples = torch.randperm(n=kwargs["high"]) + kwargs["low"]
        samples = samples[:kwargs["size"]]
        return samples.view(-1, 1)
